<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Radar</title>
    <script src="https://unpkg.com/@msgpack/msgpack@3.0.0-beta2/dist.es5+umd/msgpack.min.js"></script>
    <style>
        :root {
            --bg-dark: #0f0f1a;
            --bg-panel: #1a1a2e;
            --bg-header: #16213e;
            --border-color: #2d3a5a;
            --accent: #e94560;
            --accent-hover: #d63d56;
            --text-primary: #eee;
            --text-secondary: #888;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Main Layout */
        .app {
            display: grid;
            grid-template-rows: 48px 1fr;
            grid-template-columns: 1fr 300px;
            height: 100vh;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-header);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-dot.connected { background: var(--success); }
        .status-dot.connecting { background: var(--warning); animation: pulse 1s infinite; }
        .status-dot.error { background: var(--danger); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Radar Canvas Area */
        .radar-area {
            position: relative;
            background: var(--bg-dark);
            overflow: hidden;
        }

        #radar-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--accent);
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            padding: 4px 0;
        }

        .info-row .label {
            color: var(--text-secondary);
        }

        .info-row .value {
            font-weight: 500;
        }

        /* Player List */
        .player-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
        }

        .player-list {
            list-style: none;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.85rem;
            border: 2px solid transparent;
        }

        .player-item:hover {
            filter: brightness(1.15);
        }

        .player-item.selected {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }

        .player-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .player-info {
            flex: 1;
            min-width: 0;
        }

        .player-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-type {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .player-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .badge-pov {
            background: var(--accent);
            color: white;
        }

        .badge-dead {
            background: var(--text-secondary);
            color: var(--bg-dark);
        }

        /* Player type colors */
        .player-local { background: rgba(59, 130, 246, 0.25); }
        .player-local .player-dot { background: #3b82f6; }

        .player-teammate { background: rgba(34, 197, 94, 0.25); }
        .player-teammate .player-dot { background: #22c55e; }

        .player-pmc { background: rgba(239, 68, 68, 0.25); }
        .player-pmc .player-dot { background: #ef4444; }

        .player-scav { background: rgba(249, 115, 22, 0.25); }
        .player-scav .player-dot { background: #f97316; }

        .player-bot { background: rgba(251, 191, 36, 0.25); }
        .player-bot .player-dot { background: #fbbf24; }

        .player-dead { opacity: 0.4; }

        /* Controls */
        .controls {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 100px;
            accent-color: var(--accent);
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        /* Connection Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            color: var(--accent);
            font-size: 1.25rem;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: border-color 0.15s;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        .btn:hover {
            background: var(--accent-hover);
        }

        .error-msg {
            color: var(--danger);
            font-size: 0.85rem;
            margin-top: 12px;
            text-align: center;
        }

        /* Waiting overlay */
        .waiting-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(15, 15, 26, 0.9);
            z-index: 50;
        }

        .waiting-overlay h2 {
            color: var(--warning);
            margin-bottom: 8px;
        }

        .waiting-overlay p {
            color: var(--text-secondary);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden { display: none !important; }

        /* Responsive */
        @media (max-width: 800px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: 48px 1fr auto;
            }

            .sidebar {
                grid-row: 3;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid var(--border-color);
            }
        }
    </style>
</head>
<body>
    <!-- Connection Modal -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal">
            <h2>Connect to Radar</h2>
            <div class="form-group">
                <label>Relay Server URL</label>
                <input type="text" id="relay-url" placeholder="wss://web-radar-relay.onrender.com" />
            </div>
            <div class="form-group">
                <label>Room ID / Password</label>
                <input type="text" id="room-id" placeholder="Enter the room ID from radar app" />
            </div>
            <button class="btn" id="connect-btn">Connect</button>
            <div id="error-msg" class="error-msg hidden"></div>
        </div>
    </div>

    <!-- Main App -->
    <div class="app">
        <header class="header">
            <h1>Web Radar</h1>
            <div class="status">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text">Disconnected</span>
            </div>
        </header>

        <main class="radar-area">
            <canvas id="radar-canvas"></canvas>
            <div id="waiting-overlay" class="waiting-overlay hidden">
                <div class="spinner"></div>
                <h2>Waiting for Host</h2>
                <p>The radar host hasn't connected yet</p>
            </div>
        </main>

        <aside class="sidebar">
            <div class="sidebar-section">
                <h3>Status</h3>
                <div class="info-row">
                    <span class="label">Map</span>
                    <span class="value" id="map-name">-</span>
                </div>
                <div class="info-row">
                    <span class="label">POV</span>
                    <span class="value" id="pov-name">-</span>
                </div>
                <div class="info-row">
                    <span class="label">Players</span>
                    <span class="value" id="player-count">0</span>
                </div>
            </div>

            <div class="player-list-container">
                <h3 style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: var(--accent); margin-bottom: 8px;">Players</h3>
                <ul id="player-list" class="player-list">
                    <li style="color: var(--text-secondary); font-size: 0.85rem;">Waiting for data...</li>
                </ul>
            </div>

            <div class="controls">
                <h3 style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: var(--accent); margin-bottom: 12px;">Controls</h3>
                <div class="control-row">
                    <label>Zoom</label>
                    <input type="range" id="zoom" min="0.2" max="5" step="0.1" value="1" />
                </div>
                <div class="control-row">
                    <label>Show Map</label>
                    <input type="checkbox" id="show-map" checked />
                </div>
                <div class="control-row">
                    <label>Map Opacity</label>
                    <input type="range" id="map-opacity" min="0.1" max="1" step="0.1" value="0.7" />
                </div>
            </div>
        </aside>
    </div>

    <script>
        // Map configurations
        const MAP_CONFIGS = {
            'bigmap': {
                name: 'Customs',
                x: 369.40, y: 232.91, scale: 0.992, svgScale: 5.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Customs.svg' },
                    { minHeight: null, maxHeight: -1.8, filename: 'Customs_-1f.svg' },
                    { minHeight: -1.8, maxHeight: null, filename: 'Customs_1f.svg' },
                    { minHeight: 1.82, maxHeight: null, filename: 'Customs_2f.svg' },
                    { minHeight: 4.7, maxHeight: null, filename: 'Customs_3f.svg' }
                ]
            },
            'factory4_day': {
                name: 'Factory',
                x: 64.9, y: 67, scale: 0.994, svgScale: 36.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Factory.svg' },
                    { minHeight: null, maxHeight: -0.8, filename: 'Factory_-1f.svg' },
                    { minHeight: 2.8, maxHeight: 6.5, filename: 'Factory_2f.svg' },
                    { minHeight: 6.5, maxHeight: null, filename: 'Factory_3f.svg' }
                ]
            },
            'factory4_night': {
                name: 'Factory',
                x: 64.9, y: 67, scale: 0.994, svgScale: 36.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Factory.svg' },
                    { minHeight: null, maxHeight: -0.8, filename: 'Factory_-1f.svg' },
                    { minHeight: 2.8, maxHeight: 6.5, filename: 'Factory_2f.svg' },
                    { minHeight: 6.5, maxHeight: null, filename: 'Factory_3f.svg' }
                ]
            },
            'interchange': {
                name: 'Interchange',
                x: 397, y: 494, scale: 1.09, svgScale: 5.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Interchange.svg' },
                    { minHeight: 26, maxHeight: 31, filename: 'Interchange_1f.svg' },
                    { minHeight: 31, maxHeight: null, filename: 'Interchange_2f.svg' }
                ]
            },
            'laboratory': {
                name: 'Labs',
                x: 2356, y: -1841, scale: 8.3, svgScale: 2.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Labs_-1f.svg' },
                    { minHeight: -1, maxHeight: null, filename: 'Labs_1f.svg' },
                    { minHeight: 3, maxHeight: null, filename: 'Labs_2f.svg' }
                ]
            },
            'shoreline': {
                name: 'Shoreline',
                x: 1096, y: 648, scale: 0.995, svgScale: 3.5,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Shoreline.svg' },
                    { minHeight: null, maxHeight: -6, filename: 'Shoreline_-1f.svg' },
                    { minHeight: -4, maxHeight: -2, filename: 'Shoreline_1f.svg' },
                    { minHeight: -1, maxHeight: 1, filename: 'Shoreline_2f.svg' },
                    { minHeight: 2, maxHeight: null, filename: 'Shoreline_3f.svg' }
                ]
            },
            'woods': {
                name: 'Woods',
                x: 834.6, y: 469.6, scale: 1.048, svgScale: 4.5,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Woods.svg' }
                ]
            },
            'rezervbase': {
                name: 'Reserve',
                x: 1810, y: 1613, scale: 5.99, svgScale: 1.5,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Reserve.svg' },
                    { minHeight: null, maxHeight: -8, filename: 'Reserve_-1f.svg' }
                ]
            },
            'lighthouse': {
                name: 'Lighthouse',
                x: 544, y: 721.5, scale: 1, svgScale: 3.5,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Lighthouse.svg' }
                ]
            },
            'tarkovstreets': {
                name: 'Streets',
                x: 283, y: 534, scale: 1.0008, svgScale: 4.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Streets.svg' },
                    { minHeight: null, maxHeight: -0.7, filename: 'Streets_-1f.svg' },
                    { minHeight: -0.7, maxHeight: null, filename: 'Streets_1f.svg' },
                    { minHeight: 4.5, maxHeight: 7, filename: 'Streets_2f.svg' },
                    { minHeight: 7, maxHeight: 9.7, filename: 'Streets_3f.svg' },
                    { minHeight: 9.7, maxHeight: 12.7, filename: 'Streets_4f.svg' },
                    { minHeight: 12.7, maxHeight: null, filename: 'Streets_5f.svg' }
                ]
            },
            'Sandbox': {
                name: 'Ground Zero',
                x: 99.5, y: 364.2, scale: 1, svgScale: 8.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'GroundZero.svg' },
                    { minHeight: null, maxHeight: 16, filename: 'GroundZero_-1f.svg' },
                    { minHeight: 16, maxHeight: 26, filename: 'GroundZero_1f.svg' },
                    { minHeight: 26, maxHeight: 31, filename: 'GroundZero_2f.svg' },
                    { minHeight: 31, maxHeight: null, filename: 'GroundZero_3f.svg' }
                ]
            },
            'Sandbox_high': {
                name: 'Ground Zero',
                x: 99.5, y: 364.2, scale: 1, svgScale: 8.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'GroundZero.svg' },
                    { minHeight: null, maxHeight: 16, filename: 'GroundZero_-1f.svg' },
                    { minHeight: 16, maxHeight: 26, filename: 'GroundZero_1f.svg' },
                    { minHeight: 26, maxHeight: 31, filename: 'GroundZero_2f.svg' },
                    { minHeight: 31, maxHeight: null, filename: 'GroundZero_3f.svg' }
                ]
            },
            'Labyrinth': {
                name: 'Labyrinth',
                x: 256, y: 374, scale: 5, svgScale: 2.00,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Labyrinth.svg' }
                ]
            },
            'Terminal': {
                name: 'Terminal',
                x: 735, y: 486, scale: 1.0, svgScale: 2.0,
                layers: [
                    { minHeight: null, maxHeight: null, filename: 'Terminal.svg' }
                ]
            }
        };

        // Player type definitions
        const PLAYER_TYPES = {
            0: { name: 'AI', color: '#fbbf24', cssClass: 'player-bot' },
            1: { name: 'You', color: '#3b82f6', cssClass: 'player-local' },
            2: { name: 'Teammate', color: '#22c55e', cssClass: 'player-teammate' },
            3: { name: 'PMC', color: '#ef4444', cssClass: 'player-pmc' },
            4: { name: 'Scav', color: '#f97316', cssClass: 'player-scav' }
        };

        // Application state
        const state = {
            ws: null,
            data: null,
            zoom: 1,
            selectedPlayer: null,
            pan: { x: 0, y: 0 },
            showMap: true,
            mapOpacity: 0.7,
            mapCache: {},
            currentMapId: null,
            isDragging: false,
            lastMouse: { x: 0, y: 0 }
        };

        // DOM Elements
        const $ = id => document.getElementById(id);
        const canvas = $('radar-canvas');
        const ctx = canvas.getContext('2d');

        // Initialize from URL params
        const params = new URLSearchParams(window.location.search);
        if (params.get('relay')) $('relay-url').value = params.get('relay');
        if (params.get('room')) $('room-id').value = params.get('room');

        // Connect handler
        $('connect-btn').addEventListener('click', connect);
        $('relay-url').addEventListener('keypress', e => e.key === 'Enter' && connect());
        $('room-id').addEventListener('keypress', e => e.key === 'Enter' && connect());

        function setStatus(status, text) {
            $('status-dot').className = 'status-dot ' + status;
            $('status-text').textContent = text;
        }

        function showError(msg) {
            const el = $('error-msg');
            el.textContent = msg;
            el.classList.remove('hidden');
        }

        function connect() {
            const relayUrl = $('relay-url').value.trim();
            const roomId = $('room-id').value.trim();

            if (!relayUrl || !roomId) {
                showError('Please enter both relay URL and room ID');
                return;
            }

            $('error-msg').classList.add('hidden');
            setStatus('connecting', 'Connecting...');

            let wsUrl = relayUrl;
            if (!wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
                wsUrl = 'wss://' + wsUrl;
            }
            wsUrl += (wsUrl.includes('?') ? '&' : '?') + `role=viewer&room=${encodeURIComponent(roomId)}`;

            try {
                state.ws = new WebSocket(wsUrl);
                state.ws.binaryType = 'arraybuffer';

                state.ws.onopen = () => {
                    $('modal-overlay').classList.add('hidden');
                    $('waiting-overlay').classList.remove('hidden');
                    setStatus('connecting', 'Waiting for host...');
                };

                state.ws.onmessage = handleMessage;
                state.ws.onclose = handleDisconnect;
                state.ws.onerror = () => {
                    setStatus('error', 'Connection error');
                    showError('Connection failed. Check the relay URL.');
                };
            } catch (e) {
                showError('Invalid URL: ' + e.message);
            }
        }

        function handleMessage(event) {
            if (typeof event.data === 'string') {
                const msg = JSON.parse(event.data);
                if (msg.type === 'host_connected') {
                    $('waiting-overlay').classList.add('hidden');
                    setStatus('connected', 'Connected');
                } else if (msg.type === 'host_disconnected') {
                    $('waiting-overlay').classList.remove('hidden');
                    setStatus('connecting', 'Host disconnected');
                    state.data = null;
                } else if (msg.type === 'waiting_for_host') {
                    $('waiting-overlay').classList.remove('hidden');
                }
            } else {
                $('waiting-overlay').classList.add('hidden');
                setStatus('connected', 'Connected');
                const decoded = MessagePack.decode(new Uint8Array(event.data));
                processRadarData(decoded);
            }
        }

        function handleDisconnect() {
            setStatus('error', 'Disconnected');
            state.data = null;
            setTimeout(() => {
                $('modal-overlay').classList.remove('hidden');
                $('waiting-overlay').classList.add('hidden');
                showError('Connection closed. Please reconnect.');
            }, 1000);
        }

        function processRadarData(data) {
            state.data = {
                version: data[0],
                inGame: data[1],
                mapId: data[2],
                players: data[3] ? data[3].map(p => ({
                    name: p[0],
                    type: p[1],
                    isActive: p[2],
                    isAlive: p[3],
                    pos: { x: p[4][0], y: p[4][1], z: p[4][2] },
                    rot: { x: p[5][0], y: p[5][1] }
                })) : []
            };

            // Load maps if changed
            if (state.data.mapId && state.data.mapId !== state.currentMapId) {
                state.currentMapId = state.data.mapId;
                preloadMaps(state.currentMapId);
            }

            updateUI();
        }

        async function loadMapImage(filename) {
            if (state.mapCache[filename]) return state.mapCache[filename];

            try {
                const response = await fetch(`maps/${filename}`);
                if (!response.ok) throw new Error('Not found');
                const svgText = await response.text();
                const blob = new Blob([svgText], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const img = new Image();

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = url;
                });

                state.mapCache[filename] = img;
                return img;
            } catch (e) {
                console.warn(`Failed to load ${filename}`);
                return null;
            }
        }

        async function preloadMaps(mapId) {
            const config = MAP_CONFIGS[mapId];
            if (!config) return;
            for (const layer of config.layers) {
                loadMapImage(layer.filename);
            }
        }

        function selectPlayer(name) {
            state.selectedPlayer = name;
            state.pan = { x: 0, y: 0 };
            updateUI();
        }

        function getPovPlayer() {
            if (!state.data?.players) return null;
            if (state.selectedPlayer) {
                const found = state.data.players.find(p => p.name === state.selectedPlayer);
                if (found) return found;
            }
            return state.data.players.find(p => p.type === 1) || state.data.players[0];
        }

        function updateUI() {
            const data = state.data;
            const config = data?.mapId ? MAP_CONFIGS[data.mapId] : null;

            $('map-name').textContent = data?.inGame ? (config?.name || data?.mapId || 'Unknown') : 'Not in raid';

            const pov = getPovPlayer();
            const povNameEl = $('pov-name');
            if (pov) {
                povNameEl.textContent = pov.name;
                povNameEl.style.color = PLAYER_TYPES[pov.type]?.color || '#fff';
            } else {
                povNameEl.textContent = '-';
                povNameEl.style.color = '';
            }

            $('player-count').textContent = data?.players?.length || 0;
            updatePlayerList();
        }

        function updatePlayerList() {
            const list = $('player-list');
            const data = state.data;

            if (!data?.players?.length) {
                list.innerHTML = '<li style="color: var(--text-secondary); font-size: 0.85rem;">Waiting for data...</li>';
                return;
            }

            const pov = getPovPlayer();
            const povName = pov?.name;

            // Sort: local first, then teammates, then by type
            const sorted = [...data.players].sort((a, b) => {
                if (a.type === 1) return -1;
                if (b.type === 1) return 1;
                if (a.type === 2 && b.type !== 2) return -1;
                if (b.type === 2 && a.type !== 2) return 1;
                return a.type - b.type;
            });

            list.innerHTML = sorted.map(p => {
                const typeInfo = PLAYER_TYPES[p.type] || PLAYER_TYPES[0];
                const isSelected = p.name === povName;
                const escapedName = p.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');

                return `
                    <li class="player-item ${typeInfo.cssClass} ${!p.isAlive ? 'player-dead' : ''} ${isSelected ? 'selected' : ''}"
                        onclick="selectPlayer('${escapedName}')">
                        <span class="player-dot"></span>
                        <div class="player-info">
                            <div class="player-name">${p.name}</div>
                            <div class="player-type">${typeInfo.name}</div>
                        </div>
                        ${isSelected ? '<span class="player-badge badge-pov">POV</span>' : ''}
                        ${!p.isAlive ? '<span class="player-badge badge-dead">DEAD</span>' : ''}
                    </li>
                `;
            }).join('');
        }

        // Canvas setup
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Controls
        $('zoom').addEventListener('input', e => state.zoom = parseFloat(e.target.value));
        $('show-map').addEventListener('change', e => state.showMap = e.target.checked);
        $('map-opacity').addEventListener('input', e => state.mapOpacity = parseFloat(e.target.value));

        // Canvas mouse controls
        canvas.addEventListener('mousedown', e => {
            state.isDragging = true;
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', e => {
            if (state.isDragging) {
                state.pan.x += e.clientX - state.lastMouse.x;
                state.pan.y += e.clientY - state.lastMouse.y;
                state.lastMouse = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => state.isDragging = false);
        canvas.addEventListener('mouseleave', () => state.isDragging = false);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            state.zoom = Math.max(0.2, Math.min(5, state.zoom - e.deltaY * 0.001));
            $('zoom').value = state.zoom;
        });

        canvas.addEventListener('dblclick', () => state.pan = { x: 0, y: 0 });

        // Coordinate conversion
        function worldToMap(worldX, worldZ, config) {
            return {
                x: (config.x * config.svgScale) + (worldX * config.scale * config.svgScale),
                y: (config.y * config.svgScale) - (worldZ * config.scale * config.svgScale)
            };
        }

        function isLayerVisible(layer, height) {
            if (layer.minHeight === null && layer.maxHeight === null) return true;
            if (layer.minHeight !== null && height < layer.minHeight) return false;
            if (layer.maxHeight !== null && height > layer.maxHeight) return false;
            return true;
        }

        // Render loop
        function render() {
            const w = canvas.width;
            const h = canvas.height;

            // Clear
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, w, h);

            const data = state.data;

            if (!data?.inGame || !data?.players?.length) {
                ctx.fillStyle = '#666';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(data ? 'Not in raid' : 'Waiting for data...', w / 2, h / 2);
                requestAnimationFrame(render);
                return;
            }

            const pov = getPovPlayer();
            const config = MAP_CONFIGS[data.mapId];
            const centerX = w / 2 + state.pan.x;
            const centerY = h / 2 + state.pan.y;
            let povMapPos = { x: 0, y: 0 };

            if (pov && config) {
                povMapPos = worldToMap(pov.pos.x, pov.pos.z, config);
            }

            // Draw map
            if (state.showMap && config && pov) {
                ctx.globalAlpha = state.mapOpacity;
                const visible = config.layers.filter(l => isLayerVisible(l, pov.pos.y));

                for (const layer of visible) {
                    const img = state.mapCache[layer.filename];
                    if (img) {
                        const scale = state.zoom;
                        const drawX = centerX - (povMapPos.x * scale);
                        const drawY = centerY - (povMapPos.y * scale);
                        ctx.drawImage(img, drawX, drawY, img.width * scale, img.height * scale);
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw grid if no map showing
            if (!state.showMap || !config) {
                ctx.strokeStyle = '#1a1a3a';
                ctx.lineWidth = 1;
                const gridSize = 50 * state.zoom;
                for (let x = centerX % gridSize; x < w; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                for (let y = centerY % gridSize; y < h; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }

            // Sort players (POV last = on top)
            const players = [...data.players].sort((a, b) => {
                if (pov && a.name === pov.name) return 1;
                if (pov && b.name === pov.name) return -1;
                return 0;
            });

            // Draw players
            for (const player of players) {
                if (!player.isActive && player.type !== 1) continue;

                const typeInfo = PLAYER_TYPES[player.type] || PLAYER_TYPES[0];
                const isPov = pov && player.name === pov.name;

                // Calculate screen position
                let screenX, screenY;
                if (config) {
                    const playerMapPos = worldToMap(player.pos.x, player.pos.z, config);
                    screenX = centerX + (playerMapPos.x - povMapPos.x) * state.zoom;
                    screenY = centerY + (playerMapPos.y - povMapPos.y) * state.zoom;
                } else {
                    const offsetX = pov ? pov.pos.x : 0;
                    const offsetZ = pov ? pov.pos.z : 0;
                    screenX = centerX + (player.pos.x - offsetX) * state.zoom * 2;
                    screenY = centerY - (player.pos.z - offsetZ) * state.zoom * 2;
                }

                // Skip if off-screen
                if (screenX < -100 || screenX > w + 100 || screenY < -100 || screenY > h + 100) continue;

                const radius = isPov ? 12 : 7;
                const color = player.isAlive ? typeInfo.color : '#555';

                // Aim line
                if (player.isAlive) {
                    const aimLen = isPov ? 80 : 35;
                    const aimRad = (player.rot.x - 90) * Math.PI / 180;
                    const aimX = screenX + Math.cos(aimRad) * aimLen * state.zoom;
                    const aimY = screenY + Math.sin(aimRad) * aimLen * state.zoom;

                    ctx.strokeStyle = color + (isPov ? 'dd' : '99');
                    ctx.lineWidth = isPov ? 3 : 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(aimX, aimY);
                    ctx.stroke();
                }

                // Player dot
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                ctx.fill();

                // POV ring
                if (isPov) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Name label
                ctx.font = `${isPov ? 'bold ' : ''}11px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(player.name, screenX, screenY - radius - 6);
                ctx.fillStyle = player.isAlive ? '#fff' : '#888';
                ctx.fillText(player.name, screenX, screenY - radius - 6);

                // Height indicator
                if (pov && Math.abs(player.pos.y - pov.pos.y) > 2) {
                    const diff = player.pos.y - pov.pos.y;
                    ctx.fillStyle = diff > 0 ? '#4ade80' : '#f87171';
                    ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
                    const text = diff > 0 ? `+${Math.round(diff)}` : String(Math.round(diff));
                    ctx.strokeText(text, screenX, screenY + radius + 12);
                    ctx.fillText(text, screenX, screenY + radius + 12);
                }
            }

            // Compass
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('N', w / 2, 25);
            ctx.fillText('N', w / 2, 25);

            // POV indicator
            if (pov) {
                ctx.fillStyle = '#e94560';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'left';
                ctx.strokeText(`POV: ${pov.name}`, 12, h - 12);
                ctx.fillText(`POV: ${pov.name}`, 12, h - 12);
            }

            requestAnimationFrame(render);
        }

        // Make selectPlayer global for onclick handlers
        window.selectPlayer = selectPlayer;

        // Start rendering
        render();
    </script>
</body>
</html>
